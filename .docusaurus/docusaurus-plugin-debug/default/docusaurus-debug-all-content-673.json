{
  "docusaurus-plugin-content-docs": {
    "default": {
      "loadedVersions": [
        {
          "versionName": "current",
          "label": "Next",
          "banner": null,
          "badge": false,
          "noIndex": false,
          "className": "docs-version-current",
          "path": "/docs",
          "tagsPath": "/docs/tags",
          "isLast": true,
          "routePriority": -1,
          "sidebarFilePath": "/home/anit/work/anitshrestha-com-np/sidebars.js",
          "contentPath": "/home/anit/work/anitshrestha-com-np/docs",
          "contentPathLocalized": "/home/anit/work/anitshrestha-com-np/i18n/en/docusaurus-plugin-content-docs/current",
          "docs": [
            {
              "unversionedId": "wiki",
              "id": "wiki",
              "title": "Introduction",
              "description": "Discover things I've learned",
              "source": "@site/docs/wiki.md",
              "sourceDirName": ".",
              "slug": "/wiki",
              "permalink": "/docs/wiki",
              "draft": false,
              "tags": [],
              "version": "current",
              "sidebarPosition": 0,
              "frontMatter": {
                "sidebar_position": 0
              },
              "sidebar": "tutorialSidebar"
            }
          ],
          "drafts": [],
          "sidebars": {
            "tutorialSidebar": [
              {
                "type": "doc",
                "id": "wiki"
              }
            ]
          }
        }
      ]
    }
  },
  "docusaurus-plugin-content-blog": {
    "default": {
      "blogSidebarTitle": "Recent posts",
      "blogPosts": [
        {
          "id": "google-foobar-first-challenge-caesar-cipher",
          "metadata": {
            "permalink": "/blog/google-foobar-first-challenge-caesar-cipher",
            "source": "@site/blog/google-foobar-first-codechallenge-caesar-cipher.md",
            "title": "Google FooBar First Challenge",
            "description": "Solving Caesar Cipher",
            "date": "2020-07-19T00:00:00.000Z",
            "formattedDate": "July 19, 2020",
            "tags": [
              {
                "label": "google",
                "permalink": "/blog/tags/google"
              },
              {
                "label": "challenge",
                "permalink": "/blog/tags/challenge"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "cipher",
                "permalink": "/blog/tags/cipher"
              },
              {
                "label": "first",
                "permalink": "/blog/tags/first"
              },
              {
                "label": "caesar",
                "permalink": "/blog/tags/caesar"
              }
            ],
            "readingTime": 5.92,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Google FooBar First Challenge",
              "date": "2020-07-19",
              "tags": [
                "google",
                "challenge",
                "series",
                "cipher",
                "first",
                "caesar"
              ],
              "slug": "google-foobar-first-challenge-caesar-cipher"
            },
            "nextItem": {
              "title": "Kubernetes Volume",
              "permalink": "/blog/kubernetes-volume"
            }
          },
          "content": "## Solving Caesar Cipher\n\n![Google FooBar First Challenge](./img/google-foobar-first-challenge-solved.png)\n\nIn this post I will share my experience solving the first `Google FooBar Challenge`.\n\nWhile doing some search on Google, I received an invitation to participate in a code challenge by Google. I had no previous idea about it, frankly never heard of it. I accepted the invitation and I was redirected to [FooBar](https://foobar.withgoogle.com). After log in, a `CLI` with the instructions about the challenge and how to request a challenge was provided. The challenge had to be solved within 2 days.\n \n### The Challenge\nDecrypt a code where every lowercase letter [a..z] is replaced with the corresponding one in [z..a], while every other character (including uppercase letters and punctuation) is left untouched. That is, 'a' becomes 'z', 'b' becomes 'y', 'c' becomes 'x', etc.  For instance, the word \"vmxibkgrlm\", when decoded, would become \"encryption\".\n \n__Constraints for the solution:__\n- Java 8\n- Limited execution time\n- Prohibit usage of third-party libraries\n- Parallel processing disabled\n- Character limit to around 3000 (I don’t remember exactly)\n\n<!--truncate-->\n\n### Initial Thoughts\nThe rough idea I could come up after the analysis was:\n- Manipulation of the ASCII value of the letters\n- Simple maths, addition/subtraction, on numeric value of letters\n \nSince converting this idea into a concrete algorithm was taking longer than expected, I moved to another solution.\n \n### First Attempt\nThe next simplest design for the solution I could come up with consisted of the following data structures:\n- `HashMap` to store the encrypted letters and easy access of decrypted letters\n- `StringBuilder` to store the deciphered text\n-  Use Java 8 new method `String.chars()` API\n \n```java\npublic static String solnWithStrBuilder(String x) {\nStringBuilder stb = new StringBuilder();\nx.chars().forEach(i -> stb.append(decrypt(i)));\nreturn stb.toString();\n}\npublic static char decrypt(int encryptedVal) {\nif ( encryptedVal >= 97 && encryptedVal <= 122) {\n    char encodedChar;\n    Map<Integer, Character> decryptKey = new HashMap<>();\n    for (int i = 122, j = 97; i >= 97; i--, j++) {\n        encodedChar = (char) i;\n        decryptKey.put(j, encodedChar);\n    }\n    return decryptKey.get(encryptedVal);\n}\nelse return (char)encryptedVal;\n}\n```\n \nThe implementation provided desired output in the local environment but it failed to pass the tests.\n \n### Second Iteration\nI reflected back on the constraints and refactored the code to use more primitive data structure:\n- Replaced `StringBuilder` with `Character Array`\n \n```java\npublic static String solnWithArray(String encryptedText) {\nchar[] encryptedCharArr = new char[encryptedText.length()];\nMap<Integer, Character> decryptKey = new HashMap<>();\nchar encodedChar;\nfor (int i = 122, j = 97; i >= 97; i--, j++) {\n    encodedChar = (char) i;\n    decryptKey.put(j, encodedChar);\n}\nfor (int i = 0; i < encryptedText.length(); i++) {\n    char encryptedVal = encryptedText.charAt(i);\n    if ( encryptedVal >= 97 && encryptedVal <= 122) {\n        encryptedCharArr[i] = decryptKey.get((int)encryptedVal);\n    } else encryptedCharArr[i] = encryptedVal;\n}\nreturn new String(encryptedCharArr);\n}\n```\n \nBut again the solution did not pass! At this point I was getting a little bit frustrated because there were no proper errors thrown. The output was just a list of failed tests. I lost interest after around an hour and I went back to my previous preparation method, solving challenges from other sources.\n \n### Third Iteration\nThe next day I went back to the challenge with around 3 hours remaining. To make sure the time spent here would be worthwhile, I did some search to know more about the challenge. Only then I realized that the challenge was invitation only, and was used by Google for recruitment. Those were good enough reasons for me to continue, but then I was seriously running out of time.\n \nThen I searched for similar problems and solutions to find answers to these questions:\n- How to encrypt a letter by another\n- What are the standard encryption algorithms\n \nA simple example by [Baeldung](https://www.baeldung.com/java-caesar-cipher) answered my queries.\n \n```java\nStringBuilder result = new StringBuilder();\nfor (char character : message.toCharArray()) {\n    if (character != ' ') {\n        int originalAlphabetPosition = character - 'a';\n        int newAlphabetPosition = (originalAlphabetPosition + offset) % 26;\n        char newCharacter = (char) ('a' + newAlphabetPosition);\n        result.append(newCharacter);\n    } else {\n        result.append(character);\n    }\n}\nreturn result;\n```\n \n**“Any fool can know. The point is to understand.” - Albert Einstein**\n \nKnowing that standard encryption algorithm used was `Caesar Cipher`, I wanted to understand more that led to [Cryptography](https://github.com/codeanit/til/issues/43), [Cipher](https://github.com/codeanit/til/issues/107) and [more](https://github.com/codeanit/til/issues).\n \nKeeping in mind that the time was limited, I skimmed the contents.\n \n`A **Cipher** is a method for encrypting a message, intending to make it less readable. **Caesar Cipher** is a substitution cipher that transforms a message by shifting its letters by a given offset.`\n \nBaeldung's post also made me realize that understanding of the encryption process was important to decipher. Therefore, based on Baeldung's framework, I created an encryption system that generated the cipher from the challenge.\n \n```java\npublic static String encrypt(String textToEncrypt) {\nStringBuilder result = new StringBuilder();\nfor (char character : textToEncrypt.toCharArray()) {\n    if ( (int)character >= 97 && (int)character <= 122 ) {\n        int originalAlphabetPosition = character - 'z';\n        int newAlphabetPosition = ( originalAlphabetPosition + 25 ) % 26;\n        result.append((char) ('z' - newAlphabetPosition));\n    } else {\n        result.append(character);\n    }\n}\nreturn new String(result);\n}\n```\n \nAfter generating the exact cipher, It was pretty much easier to write a program to decipher.\n \n```java\npublic static String solutionWithOffset(String encryptedText) {\nStringBuilder result = new StringBuilder();\nfor (char character : encryptedText.toCharArray()) {\n    if ( (int)character >= 97 && (int)character <= 122 ) {\n        int originalAlphabetPosition = character - 'z';\n        int newAlphabetPosition = (originalAlphabetPosition + 25 ) % 26;\n        result.append((char) ('z' + newAlphabetPosition));\n    } else {\n        result.append(character);\n    }\n}\nreturn new String(result);\n}\n```\n \nI submitted the solution then again it failed.\n \n__Time <10mins!__\n \n### Accepted Solution\nRefactored the code:\n- Replaced `StringBuilder` with `Character Array`.\n \n```java\npublic static String solution(String x) {\nint strLength = x.length();\nchar[] encryptedCharArr = new char[strLength];\nfor (int i = 0; i < strLength; i++) {\n    int character = x.charAt(i);\n    if ( character >= 97 && character <= 122 ) {\n        int originalAlphabetPosition = character - 'z';\n        int newAlphabetPosition = (originalAlphabetPosition + 25 ) % 26;\n        encryptedCharArr[i]  = (char) ('z' + newAlphabetPosition);\n    } else {\n        encryptedCharArr[i] = (char)character;\n    }\n}\nreturn new String(encryptedCharArr);\n}\n```\n \n__Yay! All Tests Passed. Time <2mins.__\n \n**Solution Submitted.**\n \n### Review\nThe next day I reviewed the solution and recalled the overall process. Phew! It was a close call.\n \nI wanted to refactor the submitted code as it was done in a hurry. And prior to refactoring, I wrote `Unit Tests` to make sure that all the methods will work as before. Those tests did not need to be extensive covering all edge cases; neither should have many use cases, the solution had already passed Google's test cases.\n \nPreviously, I had an interview with Google in July 2019. It was more of a casual talk I had with a nice lady to see if I fit the available role at a certain location. Unfortunately, it did not work out.\n \nI am grateful for both opportunities but I have enjoyed this experience more may be because I'm more of a code person.\n \nIf code is a better language to you then please find more at [Github](https://github.com/JavaCheatsheet/codechallenge)."
        },
        {
          "id": "kubernetes-volume",
          "metadata": {
            "permalink": "/blog/kubernetes-volume",
            "source": "@site/blog/kubernetes-volume-part_6.md",
            "title": "Kubernetes Volume",
            "description": "The storage management system",
            "date": "2020-07-16T00:00:00.000Z",
            "formattedDate": "July 16, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "overview",
                "permalink": "/blog/tags/overview"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_6",
                "permalink": "/blog/tags/part-6"
              },
              {
                "label": "volume",
                "permalink": "/blog/tags/volume"
              }
            ],
            "readingTime": 2.04,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Volume",
              "date": "2020-07-16",
              "tags": [
                "kubernetes",
                "devops",
                "overview",
                "series",
                "part_6",
                "volume"
              ],
              "slug": "kubernetes-volume"
            },
            "prevItem": {
              "title": "Google FooBar First Challenge",
              "permalink": "/blog/google-foobar-first-challenge-caesar-cipher"
            },
            "nextItem": {
              "title": "Kubernetes Controller",
              "permalink": "/blog/kubernetes-controllers"
            }
          },
          "content": "## The storage management system\n\n![Kubernetes Volume](./img/kubernetes-volume.png)\n\n__Review previous parts of this series for better understanding:__ \n- [Kuberenetes Overview](https://codeanit.com/blog/kubernetes-overview)\n- [Kubernetes Objects](https://codeanit.com/blog/kubernetes-objects)\n- [Kubernetes Components](https://codeanit.com/blog/kubernetes-components)\n- [Kubernetes Service](https://codeanit.com/blog/kubernetes-services)\n- [Kubernetes Controller](https://codeanit.com/blog/kubernetes-controllers)\n\n__This is the sixth part of the Kubernetes series. In this part I will try to add more insights into Kubernetes `Volume`__\n\n# **Volume** \n`Volume`is simply an abstraction of data in the form of file and directory within a Pod. It exists as long as its Pod exists.\n\nThe lifecycle of a `Volume` is tied to the lifecycle of the `Pod`, but not to that of a `Container`. If a container within a Pod dies, the Volume persists and the newly launched container will be able to mount the same Volume and access its data. When a Pod gets restarted or dies, so do its Volumes, although if the Volumes consist of cloud block storage, they will simply be unmounted with data still accessible by future Pods.\n\n<!--truncate-->\n\nTo preserve data across Pods restarts and updates, the `PersistentVolume` (PV) and `PersistentVolumeClaim` (PVC) objects are used.\n\n`StorageClass` defines different types of storage offered which are categorized as \"classes\" setup by the Cluster Administrator. Different 'classes\" might map to quality-of-service levels, or to backup policies, or to arbitrary policies. Kubernetes itself is unopinionated about what classes represent. This concept is sometimes called \"profiles\" in other storage systems.\n\n`PersistentVolume` abstracts the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system that is provisioned manually by cluster admin or dynamically using `Storage Classes`. It is a resource in the cluster just like a node is a cluster resource. PersistentVolume are volume plugins like Volumes, but have a lifecycle independent of any individual Pod.\n\n`PersistentVolumeClaim` is a request for storage by a user. It is similar to a Pod. `Pods` consume `Node` resources and PersistentVolumeClaim consume `PersistentVolume` resources. Pods can request specific levels of resources (CPU and Memory). PersistentVolumeClaim can request specific size and access modes (e.g., they can be mounted ReadWriteOnce, ReadOnlyMany or ReadWriteMany). PersistentVolumeClaim mounts the PV at the required path. The `spec` for a PVC contains the following items:\n- `accessModes` which vary by the use case. These are:\n  - `ReadWriteOnce` – mounts the volume as read-write by a single node\n  - `ReadOnlyMany` – mounts the volume as read-only by many nodes\n  - `ReadWriteMany` – mounts the volume as read-write by many nodes\n- `resources` – the storage space that you require"
        },
        {
          "id": "kubernetes-controllers",
          "metadata": {
            "permalink": "/blog/kubernetes-controllers",
            "source": "@site/blog/kubernetes-controller-part_5.md",
            "title": "Kubernetes Controller",
            "description": "The brain of the system that keeps track of all the other parts.",
            "date": "2020-07-15T00:00:00.000Z",
            "formattedDate": "July 15, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "overview",
                "permalink": "/blog/tags/overview"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_5",
                "permalink": "/blog/tags/part-5"
              },
              {
                "label": "controllers",
                "permalink": "/blog/tags/controllers"
              }
            ],
            "readingTime": 3.045,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Controller",
              "date": "2020-07-15",
              "tags": [
                "kubernetes",
                "devops",
                "overview",
                "series",
                "part_5",
                "controllers"
              ],
              "slug": "kubernetes-controllers"
            },
            "prevItem": {
              "title": "Kubernetes Volume",
              "permalink": "/blog/kubernetes-volume"
            },
            "nextItem": {
              "title": "Kubernetes Service",
              "permalink": "/blog/kubernetes-services"
            }
          },
          "content": "## The brain of the system that keeps track of all the other parts.\n\n![Kubernetes Controller](./img/kubernetes-overview.png)\n__Review previous parts of this series for better understanding:__ \n- [Kuberenetes Overview](https://codeanit.com/blog/kubernetes-overview)\n- [Kubernetes Objects](https://codeanit.com/blog/kubernetes-objects)\n- [Kubernetes Components](https://codeanit.com/blog/kubernetes-components)\n- [Kubernetes Service](https://codeanit.com/blog/kubernetes-services)\n\n__This is fifth part of the Kubernetes series. In this part I will try to add more insights into Kubernetes `Controller`.__\n\n\n# What is a Controller in Kubernetes?\nA `Controller` is a non-terminating loop that regulates the state of a system. It watches the state of the cluster, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state. There are different types of controllers for specific purposes.\n\n# **Kubernetes Control Plane** \n`Kubernetes Control Plane` is a collection of the Controllers. `kube-apiserver`, `kube-controller-manager` and `kube-scheduler` are the three critical processes that makes up the control plane. Nodes that runs these processes are called `Master Node` which are replicated for availability and redundancy.\n\n<!--truncate-->\n\n# Controller Types\nLogically, each `Controller` is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process. \n\n- `Node Controller`: Responsible for noticing and responding when nodes go down.\n\n- `Replication Controller`: Responsible for maintaining the correct number of pods for every replication controller object in the system.\n\n- `Endpoints Controller`: Populates the Endpoints object (that is, joins Services & Pods).\n\n- `Service Account & Token Controllers`: Create default accounts and API access tokens for new namespaces\n\n- `Deployments` are most frequently used objects for _stateless application_ which makes life cycle management of replicated Pods easier. It manages `Pods` as rolling updates, canary deploys and blue/green deployments. Deployments can be modified easily by changing the configuration and Kubernetes will adjust the replica sets, manage transitions between different application versions, and optionally maintain event history and undo capabilities automatically. \n\n- `Stateful Sets` are specialized pod controllers for _stateful applications_ that offer ordering and uniqueness guarantees. Primarily it is used when systems that require stable network identifiers, stable persistent storage, and ordering guarantees like data-oriented applications, like databases, which need access to the same volumes even if rescheduled to a new node.\n\n- `Replication Controller` is responsible for ensuring that the number of Pods deployed in the cluster matches the number of pods in its configuration. If a Pod or underlying host fails, the Controller will start new pods to compensate. If the number of replicas in a Controller’s configuration changes, the Controller either starts up or kills Containers to match the desired number. Replication Controllers can also perform rolling updates to roll over a set of pods to a new version one by one, minimizing the impact on application availability. `Deployments` uses as it's build block.\n\n- `Replication Sets` are an iteration on the `Replication Controller` design with greater flexibility in how the controller identifies the Pods it is meant to manage. The only thing it does not do is rolling updates.\n\n- `Daemon Sets` are another specialized form of Pod Controller that run a copy of a Pod on each node in the cluster (or a subset, if specified). This is most often useful when deploying pods that help perform maintenance and provide services for the nodes themselves. For instance, collecting and forwarding logs, aggregating metrics, and running services that increase the capabilities of the node itself are popular candidates for daemon sets.\n\n- `Jobs` are useful when containers are expected to exit successfully after some time once they have completed their work. \nBuild on jobs, \n\n\n# Review\n**Controller** are the essential parts of Kubernetes which makes `Pods` management easy Kubernetes.\n\n\n__I will share about [Kubernetes Volume](https://codeanit.com/blog/kubernetes-volume) next.__"
        },
        {
          "id": "kubernetes-services",
          "metadata": {
            "permalink": "/blog/kubernetes-services",
            "source": "@site/blog/kubernetes-service-part_4.md",
            "title": "Kubernetes Service",
            "description": "An important component that manages routes and containers.",
            "date": "2020-07-14T00:00:00.000Z",
            "formattedDate": "July 14, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "overview",
                "permalink": "/blog/tags/overview"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_4",
                "permalink": "/blog/tags/part-4"
              },
              {
                "label": "services",
                "permalink": "/blog/tags/services"
              }
            ],
            "readingTime": 2.11,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Service",
              "date": "2020-07-14",
              "tags": [
                "kubernetes",
                "devops",
                "overview",
                "series",
                "part_4",
                "services"
              ],
              "slug": "kubernetes-services"
            },
            "prevItem": {
              "title": "Kubernetes Controller",
              "permalink": "/blog/kubernetes-controllers"
            },
            "nextItem": {
              "title": "Kubernetes Components",
              "permalink": "/blog/kubernetes-components"
            }
          },
          "content": "## An important component that manages routes and containers.\n\n![Kubernetes Services](./img/kubernetes-service.png)\n\n__Review previous parts of this series for better understanding:__ \n- [Kuberenetes Overview](https://codeanit.com/blog/kubernetes-overview)\n- [Kubernetes Objects](https://codeanit.com/blog/kubernetes-objects)\n- [Kubernetes Components](https://codeanit.com/blog/kubernetes-components)\n\n__This is fourth part of the Kubernetes series. In this part I will try to add more insights into Kubernetes `Service`.__\n\n\n# What is a Service in Kubernetes? \nA `Service` groups `Pods` together that perform the same function as a single entity. It keeps track of containers in the Pods and routes to the containers for internal and external access. A Service’s IP address remains stable regardless of changes to the Pods it routes to, which makes it easy to gain discoverability and can simplify containers designs. By default, Services are only available using an internally routable IP address, they can be made available outside of the Cluster by choosing one of several strategies.\n\n# Types Of Services\nThere are 4 types of Services, specified by the type `field` in the `Service Configuration File`:\n\n<!--truncate-->\n\n- `ClusterIP` is the default, which grants the Service a stable internal IP accessible from anywhere inside of the cluster.\n\n- `NodePort` configuration works by opening a static port on each node’s external networking interface. Traffic to the external port will be routed automatically to the appropriate pods using an internal cluster IP service. This will expose your Service on each Node at a static port, between 30000-32767 by default. When a request hits a Node at its Node IP address and the NodePort for your service, the request will be load balanced and routed to the application containers for your service.\n\n- `LoadBalancer` creates an external load-balancer to route to the service using a cloud provider’s Kubernetes load-balancer integration. The `Cloud Controller Manager` will create the appropriate resource and configure it using the internal service service addresses. This will create a load balancer using your cloud provider’s load balancing product, and configure a NodePort and ClusterIP for your Service to which external requests will be routed.\nCreating LoadBalancer for each Deployment running in the cluster will create a new cloud load balancer for each Service, which can become costly. `Ingress Controller` is used to manage routing external requests to multiple services using a single load balancer.\n\n - `ExternalName` allows to map a Kubernetes Service to a DNS record. It can be used for accessing external services from Pods using Kubernetes DNS.\n\n\n# Review\n**Services** are the essential parts of Kubernetes which provides secure communication mechanism with in the Kubernetes infrastructure.\n\n\n__I will share about [Kubernetes Controller](https://codeanit.com/blog/kubernetes-controllers) next.__"
        },
        {
          "id": "kubernetes-components",
          "metadata": {
            "permalink": "/blog/kubernetes-components",
            "source": "@site/blog/kubernetes-components-part_3.md",
            "title": "Kubernetes Components",
            "description": "A quick look at the building blocks in simple terms for quick understanding.",
            "date": "2020-07-12T00:00:00.000Z",
            "formattedDate": "July 12, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "basics",
                "permalink": "/blog/tags/basics"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_3",
                "permalink": "/blog/tags/part-3"
              },
              {
                "label": "components",
                "permalink": "/blog/tags/components"
              }
            ],
            "readingTime": 5.21,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Components",
              "date": "2020-07-12",
              "tags": [
                "kubernetes",
                "devops",
                "basics",
                "series",
                "part_3",
                "components"
              ],
              "slug": "kubernetes-components"
            },
            "prevItem": {
              "title": "Kubernetes Service",
              "permalink": "/blog/kubernetes-services"
            },
            "nextItem": {
              "title": "Kubernetes Objects",
              "permalink": "/blog/kubernetes-objects"
            }
          },
          "content": "## A quick look at the building blocks in simple terms for quick understanding.\n\n![Kubernetes Components](./img/kubernetes-overview.png)\n\n__Review previous parts of this series for better understanding:__ \n- [Kuberenetes Overview](https://codeanit.com/blog/kubernetes-overview)\n- [Kubernetes Objects](https://codeanit.com/blog/kubernetes-objects)\n\n__This is third part of the Kubernetes series. In this part I will try to add more insights into the essential parts  of Kubernetes. I will add more details on the topics in later in the series or there will separate posts as the topics needs.__\n\n\n# **Container** \n`Container` is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. The container runtime is responsible for starting and managing containers.\n\n# **Kubernetes** \n`Kubernetes` is a powerful container orchestration system that can manage the deployment and operation of containerized applications across clusters of servers. In addition to coordinating container workloads, Kubernetes provides the infrastructure and tools necessary to maintain reliable network connectivity between your applications and services.\n\n# **Node**\nA `Node` is physical or virtual machine. Every cluster must have at least one `Master Node` which controls cluster, and one or many `Worker Node` that hosts `Pod`.\n\n<!--truncate-->\n\n# **Cluster**\n`Cluster` is a group of interconnected `Node`. Cluster's state is defined `Kubernetes Objects`. Cluster's desired state includes what applications or other workloads to run, what container images they use, the number of replicas, what network and disk resources to make available.\n\n# **Namespace**\n`Namespace` is way to divide cluster resources between users by creating multiple virtual `Clusters` in same physical `Cluster`. They are used in environments with many users spread across multiple teams, or projects. Namespaces can not be nested inside one another and each Kubernetes resource can only be in one Namespace. Objects in the same Namespace will have the same access control policies by default. `Labels` are used to distinguish resources within the same Namespace. `Namespace` resources are not themselves in a `Namespace`, and low-level resources, such as `Nodes` and `PersistentVolumes`, are not in any Namespace.\n\n# **Pod** \nA `Pod` represents a group of one or more `Containers` running together and operating closely as a single, monolithic application in a `Node` in the `Cluster`. Pods are managed entirely as a unit and share resources like environment, volumes and IP space. Pods consist of a main container which serves workload and optionally some helper containers that facilitate closely related tasks. For example, a Pod may have one container running the primary application server and a helper container pulling down files to the shared filesystem when changes are detected in an external repository. Pods are managed by higher level objects by providing template definitions.  \n\n# **Service** \nA `Service` groups `Pods` together that perform the same function as a single entity. It keeps track of containers in the pods and routes to the containers for internal and external access. A service’s IP address remains stable regardless of changes to the pods it routes to which makes it easy to gain discoverability and can simplify containers designs. By default, services are only available using an internally routable IP address, they can be made available outside of the cluster by choosing one of several strategies.\n\n# **Kubernetes API** \n`Kubernetes API` is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating, updating, and deleting primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET), includes additional subresources for many objects that allow fine grained authorization (such as binding a pod to a node), and can accept and serve those resources in different representations for convenience or efficiency. It also supports efficient change notifications on resources via \"watches\" and consistent lists to allow other components to effectively cache and synchronize the state of resources. It the communication medium for the end users, different parts of your cluster, and external components with one another. Most Kubernetes API resource types are `Kubernetes Objects`, but a smaller number of API resource types are  represented by operations.  \n\n# **Controller**\nA `Controller` is a non-terminating loop that regulates the state of a system. It watches the state of the cluster, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state. There are different types of controllers for specific purposes.\n\n# **Volume** \n`Volume`is simply an abstraction of data in the form of file and directory within a Pod. It exists as long as its Pod exists.\n\n# **Secrets** \n`Secrets` are used to share sensitive information, like SSH keys and passwords, with other `Kubernetes Objects` within the same namespace. \n\n# Security And Policies\nSecurity in Kubernetes is a big challenge as it is a composed many smaller standalone components. It provides many security mechanisms. `Namespaces` can be used for authentication, authorization and access control. `Resource Quotas` can be provided to avoid resource cannibalization. And `Network Policies` can be setup for proper segmentation and traffic control.\n\n# Networking\nAll the components of Kubernetes are interconnected. For the entire system to function efficiently, reliability and securely, networking plays critical role. The basic requirements of a Kubernetes network are:\n  - all containers can communicate with all other containers without NAT\n  - all nodes can communicate with all containers (and vice-versa) without NAT\n  - the IP that a container sees itself as is the same IP that others see it as\n\nNetwork Address Translation(NAT) is a method of remapping an IP address space into another by modifying network address information in the IP header of packets while they are in transit across a traffic routing device\n\n# Monitoring\nKubernetes includes some internal monitoring tools by default. These resources belong to its [resource metrics pipeline](https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/#resource-metrics-pipeline), which ensures that the cluster runs as expected. The [cAdvisor](https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/#cadvisor) component collects network usage, memory, and CPU statistics from individual containers and nodes and passes that information to kubelet; kubelet in turn exposes that information via a REST API. The [Metrics Server](https://kubernetes.io/docs/tasks/debug-application-cluster/core-metrics-pipeline/#metrics-server) gets this information from the API and then passes it to the kube-aggregator for formatting. \n\n\n# Review\n**Kubernetes** is a large system with many parts functioning as a unit. It has resolved many issues in managing containerized distributed application but before using it in production, it is recommended to understand it very well.\n\n\n__I will share about [Kubernetes Service](https://codeanit.com/blog/kubernetes-services) next.__"
        },
        {
          "id": "kubernetes-objects",
          "metadata": {
            "permalink": "/blog/kubernetes-objects",
            "source": "@site/blog/kubernetes-objects-part_2.md",
            "title": "Kubernetes Objects",
            "description": "Essential building blocks of the complicated system.",
            "date": "2020-07-09T00:00:00.000Z",
            "formattedDate": "July 9, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "basics",
                "permalink": "/blog/tags/basics"
              },
              {
                "label": "overview",
                "permalink": "/blog/tags/overview"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_2",
                "permalink": "/blog/tags/part-2"
              },
              {
                "label": "objects",
                "permalink": "/blog/tags/objects"
              }
            ],
            "readingTime": 1.665,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Objects",
              "date": "2020-07-09",
              "tags": [
                "kubernetes",
                "devops",
                "basics",
                "overview",
                "series",
                "part_2",
                "objects"
              ],
              "slug": "kubernetes-objects"
            },
            "prevItem": {
              "title": "Kubernetes Components",
              "permalink": "/blog/kubernetes-components"
            },
            "nextItem": {
              "title": "Kubernetes Overview",
              "permalink": "/blog/kubernetes-overview"
            }
          },
          "content": "## Essential building blocks of the complicated system.\n\n![Kubernetes Object](./img/kubernetes-objects.png)\n\n__Review [Kuberenetes Overview](https://codeanit.com/blog/kubernetes-overview)__\n\n__This is the second part of the Kubernetes series. In this part I will try to add more insights into Kubenetes Objects.__\n\n\n# **Kubernetes Objects**\n`Kubernetes Objects` are persistent entities in `Kubernetes`. All objects have unique names that allows idempotent creation and retrieval. These objects are stored in `etcd`database as a key-value pair. Objects can categorized as the `Basic Objects` which determines the deployed containerized application's workloads, their associated network and disk resources, and `Higher Level Objects` which are build upon the basic objects to provide additional functionality and convenience features to manage the workloads. Higher level objects have a long-running service-like lifecycle, except `Jobs`. \n  - Basic Objects: Pod, Service, Volume and Namespace \n  - Higher Level Objects: Replication Controllers, Replication Sets, Deployments, Stateful Sets, Daemon Sets Jobs and Cron Jobs\n\nEvery `Kubernetes Object` definition is a `YAML` file that contains at least the following items:\n- `apiVersion`: The version of the Kubernetes API that the definition belongs to.\n- `kind`: The Kubernetes object this file represents. For example, a pod or service.\n- `metadata`: This contains the name of the object along with any labels that you may wish to apply to it.\n- `spec`: This contains a specific configuration depending on the kind of object you are creating, such as the container image or the ports on which the container will be accessible from.\n\n<!--truncate-->\n\nInstead of a `spec` key, a `Secret` uses a `data` or `stringData` key to hold the required information. The `data` parameter holds base64 encoded data that is automatically decoded when retrieved. The `stringData` parameter holds non-encoded data that is automatically encoded during creation or updates, and does not output the data when retrieving Secrets.\n\n\n# Review\nKubernetes Objects are the fundamental units that define how the many units exists and functions together.\nThese building blocks must be understood in details to make the good use of Kubernetes.\n\n\n__I will share about [Kubernetes Components](https://codeanit.com/blog/kubernetes-components) next.__"
        },
        {
          "id": "kubernetes-overview",
          "metadata": {
            "permalink": "/blog/kubernetes-overview",
            "source": "@site/blog/kubernetes-overview-part_1.md",
            "title": "Kubernetes Overview",
            "description": "The easiest way to visualize components and how they work.",
            "date": "2020-07-01T00:00:00.000Z",
            "formattedDate": "July 1, 2020",
            "tags": [
              {
                "label": "kubernetes",
                "permalink": "/blog/tags/kubernetes"
              },
              {
                "label": "devops",
                "permalink": "/blog/tags/devops"
              },
              {
                "label": "overview",
                "permalink": "/blog/tags/overview"
              },
              {
                "label": "series",
                "permalink": "/blog/tags/series"
              },
              {
                "label": "part_1",
                "permalink": "/blog/tags/part-1"
              }
            ],
            "readingTime": 1.875,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Kubernetes Overview",
              "date": "2020-07-01",
              "tags": [
                "kubernetes",
                "devops",
                "overview",
                "series",
                "part_1"
              ],
              "slug": "kubernetes-overview"
            },
            "prevItem": {
              "title": "Kubernetes Objects",
              "permalink": "/blog/kubernetes-objects"
            },
            "nextItem": {
              "title": "Website With GatsbyJS",
              "permalink": "/blog/website-with-gatsby"
            }
          },
          "content": "## The easiest way to visualize components and how they work.\n\n![Kubernetes Overview](./img/kubernetes-banner.png)\n\n__This is the first part of the Kubernetes series. In this part I will surficially touch things realted to Kubenetes quickly.__\n\n\n# Evolution Of Hosting\n![](./img/application_hosting_evolution.svg)\n\nTraditionally, applications used to run on one or more `Physical Servers`. The main drawback was that they did not scale well as resources were not utilized to the maximum. `Virtual Machines` solved the problem and enhanced security of applications by providing isolated environments which enabled adoption of distributed systems tremendously. Then, with the large number of applications running in the Virtual Machines, maintenance started to become cumbersome. Now there are `Containerization` technologies which solved the problems of Virtual Machines by abstracting and enhancing their entire functionalities. `Kubernetes` has made it extremely easy to manage the `Containerized Applications`. \n\n# Kubernetes Architecture\n![](./img/kubernetes-architecture.svg)\n\n<!--truncate-->\n\n# Kubernetes Objects\n- Cluster is the pool of compute, storage, and network resources.\n- Node is a host machine running within the Cluster.\n- Namespace is the logical partitions of a Cluster.\n- Pod is the basic unit of deployment.\n- Labels are key-value pairs for identification and service discovery.\n- Services identifies a set of Pods using Label selectors.\n- Replication Sets ensures Pod's availability and scalability.\n- Deployment manages Pod's lifecycle.\n- Volume provies storage capability.\n- Ingress exposes HTTP and HTTPS routes from outside the Cluster to Services.\n\n\n# Core Processes\n- `kube-controller-manager` manages other processes regulates the states of the `Kubernetes`. \n- `kube-apiserver` is the implementation of the `Kubernetes API`.\n- `kube-scheduler` watches for newly created `Pods` with no assigned `Node`, and selects a Node for them to run on.\n- `kubelet` communicates with the `Master Node` or the `Controller`.\n- `kube-proxy` is a `Network Proxy` which reflects Kubernetes networking services on each Node.\n\n# High Level Overview Of Kubenetes\n![](./img/kubernetes-overview.png)\n\n# Namespace \n![](./img/kubernetes-namespace.png)\n\n# Service\n![](./img/kubernetes-service.png)\n\n# Volume\n![](./img/kubernetes-volume.png)\n\n# An Example Of How Request Flows In Kubernetes\n![](./img/kubernetes-services-iptables-overview.svg)\n\n# Example of Request Flow via Pod\n![](./img/kubernetes-request_flow-cluster-service-pod.jpg)\n\n\n# Review\n**Kubernetes** is a large system with many parts functioning as a unit. \nAlthough it has simplified managing containerized distributed application, it is recommended to understand it very well befor using it production.\n\n\n__I will share about [Kubernetes Objects](https://codeanit.com/blog/kubernetes-objects) next.__"
        },
        {
          "id": "website-with-gatsby",
          "metadata": {
            "permalink": "/blog/website-with-gatsby",
            "source": "@site/blog/website-with-gatsbyjs.md",
            "title": "Website With GatsbyJS",
            "description": "Building a static website with GatsbyJS.",
            "date": "2020-06-09T00:00:00.000Z",
            "formattedDate": "June 9, 2020",
            "tags": [
              {
                "label": "website",
                "permalink": "/blog/tags/website"
              },
              {
                "label": "blog",
                "permalink": "/blog/tags/blog"
              },
              {
                "label": "gatsby",
                "permalink": "/blog/tags/gatsby"
              },
              {
                "label": "javascript",
                "permalink": "/blog/tags/javascript"
              },
              {
                "label": "typescript",
                "permalink": "/blog/tags/typescript"
              },
              {
                "label": "jam-stack",
                "permalink": "/blog/tags/jam-stack"
              },
              {
                "label": "static-wesite",
                "permalink": "/blog/tags/static-wesite"
              }
            ],
            "readingTime": 2.015,
            "hasTruncateMarker": true,
            "authors": [],
            "frontMatter": {
              "title": "Website With GatsbyJS",
              "date": "2020-06-09",
              "tags": [
                "website",
                "blog",
                "gatsby",
                "javascript",
                "typescript",
                "jam-stack",
                "static-wesite"
              ],
              "slug": "website-with-gatsby"
            },
            "prevItem": {
              "title": "Kubernetes Overview",
              "permalink": "/blog/kubernetes-overview"
            }
          },
          "content": "## Building a static website with GatsbyJS. \n\n![Gatsby Logo](./img/gatsbyjs-logo-banner.jpg)\n\nThe recent trends of static websites built with [JAMStack](https://jamstack.org) is on the rise. Free hosting providers such as [Github](https://github.io) and [Netlify](https://netlify.com) has made JAMStack more attractive. \n\nI have choosen [GatsbyJS](https://www.gatsbyjs.org) to develop this website.\n\n\n### Why Gatsby?\nGatsby is open-sourced blazing fast modern site generator with a great community. It is build on top of ReactJS with GraphQL as the data provider and uses Webpack to build Progressive Web App easily. \n\n<!-- truncate -->\n\n![Gatsby powered by with React, GraphQL, Webpack](./img/react-graphql-webpack.png)\n\n\nI love [Markdown](https://en.wikipedia.org/wiki/Markdown). Markdown is a plain text formatting syntax aimed at making writing for the internet easier. The philosophy behind Markdown is that plain text documents should be readable without tags mussing everything up, but there should still be ways to add text modifiers like lists, bold, italics, etc. It is an alternative to WYSIWYG (what you see is what you get) editors, which use rich text that later gets converted to proper HTML. And the best thing about it is that it's dead simple to learn. Gatsby provides an easier way to transform Markdown files into HTML content using [gatsby-source-filesystem](https://www.gatsbyjs.org/packages/gatsby-source-filesystem) plugin. \n\nGatsby provides a number of good plugins to make the development faster. Some commonly used plugins are: \n- [gatsby-plugin-sharp](https://www.gatsbyjs.org/packages/gatsby-plugin-sharp) exposes several image processing functions\n- [gatsby-plugin-react-helmet](https://www.gatsbyjs.org/packages/gatsby-plugin-react-helmet) provides drop-in server rendering support \n\nMany more can be found at https://www.gatsbyjs.org/plugins.\n\nFurthermore, there are many open source Gatsby built websites for reference. The collection of resources can be found at https://github.com/GatsbyCheatsheet. \n \n\n### The Development Journey\nGatsby provides good [tutorials](https://www.gatsbyjs.org/tutorial) to get started with. It makes building website easier for the developers. One thing I felt missing was a good example which shows how to start from defining data type and mapping it to generate GraphQL nodes. This [repository](https://github.com/GatsbyCheatsheet/police-brutality-site) filled that gap a more in that context. \n\nGatsby also provides a concept of theme but that seems to be a complete system rather than just user interfaces. I was looking forward to find an example site with a good reference that implements theme and built on top of TypeScript and [Maximeheckel.com](https://github.com/GatsbyCheatsheet/blog.maximeheckel.com) provided enough help. [System-ui.com](https://github.com/GatsbyCheatsheet/system-ui.com) provided insights using theme, components and CSS.\n\n\n### Overall\nThe journey to built website on Gatsby was challenging. I learned a lot about  Gatsby and modern frontend development technologies and methodology.  I intend to make the website more useful with quality contents and functionality to add great user experience."
        }
      ],
      "blogListPaginated": [
        {
          "items": [
            "google-foobar-first-challenge-caesar-cipher",
            "kubernetes-volume",
            "kubernetes-controllers",
            "kubernetes-services",
            "kubernetes-components",
            "kubernetes-objects",
            "kubernetes-overview",
            "website-with-gatsby"
          ],
          "metadata": {
            "permalink": "/blog",
            "page": 1,
            "postsPerPage": 10,
            "totalPages": 1,
            "totalCount": 8,
            "blogDescription": "Blog",
            "blogTitle": "Blog"
          }
        }
      ],
      "blogTags": {
        "/blog/tags/google": {
          "label": "google",
          "items": [
            "google-foobar-first-challenge-caesar-cipher"
          ],
          "permalink": "/blog/tags/google",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher"
              ],
              "metadata": {
                "permalink": "/blog/tags/google",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/challenge": {
          "label": "challenge",
          "items": [
            "google-foobar-first-challenge-caesar-cipher"
          ],
          "permalink": "/blog/tags/challenge",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher"
              ],
              "metadata": {
                "permalink": "/blog/tags/challenge",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/series": {
          "label": "series",
          "items": [
            "google-foobar-first-challenge-caesar-cipher",
            "kubernetes-volume",
            "kubernetes-controllers",
            "kubernetes-services",
            "kubernetes-components",
            "kubernetes-objects",
            "kubernetes-overview"
          ],
          "permalink": "/blog/tags/series",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher",
                "kubernetes-volume",
                "kubernetes-controllers",
                "kubernetes-services",
                "kubernetes-components",
                "kubernetes-objects",
                "kubernetes-overview"
              ],
              "metadata": {
                "permalink": "/blog/tags/series",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 7,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/cipher": {
          "label": "cipher",
          "items": [
            "google-foobar-first-challenge-caesar-cipher"
          ],
          "permalink": "/blog/tags/cipher",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher"
              ],
              "metadata": {
                "permalink": "/blog/tags/cipher",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/first": {
          "label": "first",
          "items": [
            "google-foobar-first-challenge-caesar-cipher"
          ],
          "permalink": "/blog/tags/first",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher"
              ],
              "metadata": {
                "permalink": "/blog/tags/first",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/caesar": {
          "label": "caesar",
          "items": [
            "google-foobar-first-challenge-caesar-cipher"
          ],
          "permalink": "/blog/tags/caesar",
          "pages": [
            {
              "items": [
                "google-foobar-first-challenge-caesar-cipher"
              ],
              "metadata": {
                "permalink": "/blog/tags/caesar",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/kubernetes": {
          "label": "kubernetes",
          "items": [
            "kubernetes-volume",
            "kubernetes-controllers",
            "kubernetes-services",
            "kubernetes-components",
            "kubernetes-objects",
            "kubernetes-overview"
          ],
          "permalink": "/blog/tags/kubernetes",
          "pages": [
            {
              "items": [
                "kubernetes-volume",
                "kubernetes-controllers",
                "kubernetes-services",
                "kubernetes-components",
                "kubernetes-objects",
                "kubernetes-overview"
              ],
              "metadata": {
                "permalink": "/blog/tags/kubernetes",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 6,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/devops": {
          "label": "devops",
          "items": [
            "kubernetes-volume",
            "kubernetes-controllers",
            "kubernetes-services",
            "kubernetes-components",
            "kubernetes-objects",
            "kubernetes-overview"
          ],
          "permalink": "/blog/tags/devops",
          "pages": [
            {
              "items": [
                "kubernetes-volume",
                "kubernetes-controllers",
                "kubernetes-services",
                "kubernetes-components",
                "kubernetes-objects",
                "kubernetes-overview"
              ],
              "metadata": {
                "permalink": "/blog/tags/devops",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 6,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/overview": {
          "label": "overview",
          "items": [
            "kubernetes-volume",
            "kubernetes-controllers",
            "kubernetes-services",
            "kubernetes-objects",
            "kubernetes-overview"
          ],
          "permalink": "/blog/tags/overview",
          "pages": [
            {
              "items": [
                "kubernetes-volume",
                "kubernetes-controllers",
                "kubernetes-services",
                "kubernetes-objects",
                "kubernetes-overview"
              ],
              "metadata": {
                "permalink": "/blog/tags/overview",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 5,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-6": {
          "label": "part_6",
          "items": [
            "kubernetes-volume"
          ],
          "permalink": "/blog/tags/part-6",
          "pages": [
            {
              "items": [
                "kubernetes-volume"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-6",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/volume": {
          "label": "volume",
          "items": [
            "kubernetes-volume"
          ],
          "permalink": "/blog/tags/volume",
          "pages": [
            {
              "items": [
                "kubernetes-volume"
              ],
              "metadata": {
                "permalink": "/blog/tags/volume",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-5": {
          "label": "part_5",
          "items": [
            "kubernetes-controllers"
          ],
          "permalink": "/blog/tags/part-5",
          "pages": [
            {
              "items": [
                "kubernetes-controllers"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-5",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/controllers": {
          "label": "controllers",
          "items": [
            "kubernetes-controllers"
          ],
          "permalink": "/blog/tags/controllers",
          "pages": [
            {
              "items": [
                "kubernetes-controllers"
              ],
              "metadata": {
                "permalink": "/blog/tags/controllers",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-4": {
          "label": "part_4",
          "items": [
            "kubernetes-services"
          ],
          "permalink": "/blog/tags/part-4",
          "pages": [
            {
              "items": [
                "kubernetes-services"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-4",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/services": {
          "label": "services",
          "items": [
            "kubernetes-services"
          ],
          "permalink": "/blog/tags/services",
          "pages": [
            {
              "items": [
                "kubernetes-services"
              ],
              "metadata": {
                "permalink": "/blog/tags/services",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/basics": {
          "label": "basics",
          "items": [
            "kubernetes-components",
            "kubernetes-objects"
          ],
          "permalink": "/blog/tags/basics",
          "pages": [
            {
              "items": [
                "kubernetes-components",
                "kubernetes-objects"
              ],
              "metadata": {
                "permalink": "/blog/tags/basics",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-3": {
          "label": "part_3",
          "items": [
            "kubernetes-components"
          ],
          "permalink": "/blog/tags/part-3",
          "pages": [
            {
              "items": [
                "kubernetes-components"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-3",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/components": {
          "label": "components",
          "items": [
            "kubernetes-components"
          ],
          "permalink": "/blog/tags/components",
          "pages": [
            {
              "items": [
                "kubernetes-components"
              ],
              "metadata": {
                "permalink": "/blog/tags/components",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-2": {
          "label": "part_2",
          "items": [
            "kubernetes-objects"
          ],
          "permalink": "/blog/tags/part-2",
          "pages": [
            {
              "items": [
                "kubernetes-objects"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-2",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/objects": {
          "label": "objects",
          "items": [
            "kubernetes-objects"
          ],
          "permalink": "/blog/tags/objects",
          "pages": [
            {
              "items": [
                "kubernetes-objects"
              ],
              "metadata": {
                "permalink": "/blog/tags/objects",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/part-1": {
          "label": "part_1",
          "items": [
            "kubernetes-overview"
          ],
          "permalink": "/blog/tags/part-1",
          "pages": [
            {
              "items": [
                "kubernetes-overview"
              ],
              "metadata": {
                "permalink": "/blog/tags/part-1",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/website": {
          "label": "website",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/website",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/website",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/blog": {
          "label": "blog",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/blog",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/blog",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/gatsby": {
          "label": "gatsby",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/gatsby",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/gatsby",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/javascript": {
          "label": "javascript",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/javascript",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/javascript",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/typescript": {
          "label": "typescript",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/typescript",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/typescript",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/jam-stack": {
          "label": "jam-stack",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/jam-stack",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/jam-stack",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/blog/tags/static-wesite": {
          "label": "static-wesite",
          "items": [
            "website-with-gatsby"
          ],
          "permalink": "/blog/tags/static-wesite",
          "pages": [
            {
              "items": [
                "website-with-gatsby"
              ],
              "metadata": {
                "permalink": "/blog/tags/static-wesite",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        }
      },
      "blogTagsListPath": "/blog/tags"
    }
  },
  "docusaurus-plugin-content-pages": {
    "default": [
      {
        "type": "jsx",
        "permalink": "/",
        "source": "@site/src/pages/index.tsx"
      },
      {
        "type": "mdx",
        "permalink": "/markdown-page",
        "source": "@site/src/pages/markdown-page.md",
        "title": "Markdown page example",
        "description": "You don't need React to write simple standalone pages.",
        "frontMatter": {
          "title": "Markdown page example"
        }
      }
    ]
  },
  "docusaurus-plugin-debug": {},
  "docusaurus-theme-classic": {},
  "docusaurus-bootstrap-plugin": {},
  "docusaurus-mdx-fallback-plugin": {}
}